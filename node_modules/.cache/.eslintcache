[{"/home/ahmad/Documents/Discrete/algo-visualizer/src/index.js":"1","/home/ahmad/Documents/Discrete/algo-visualizer/src/App.js":"2","/home/ahmad/Documents/Discrete/algo-visualizer/src/reportWebVitals.js":"3","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/Layout/Layout.js":"4","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Canvas.js":"5","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Header/Header.js":"6","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Menu/AlgorithmOptions.js":"7","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Edge.js":"8","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Vertex.js":"9","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Header/Drawer.js":"10","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/AdjList/AdjList.js":"11","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/TopoModal/TopoModal.js":"12","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/BFS/BfsVisualization.js":"13","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Prim/PrimVisualization.js":"14","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/TopologicalSort/TopologicalSortVisualization.js":"15","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Kruskal/KruskalVisualization.js":"16","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Dijkstra/DijkstraVisualization.js":"17","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/DFS/DfsVisualization.js":"18","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Menu/Menu.js":"19","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/Queue.js":"20","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/asyncTimeOut.js":"21","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/Stack.js":"22","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/UnionFind.js":"23","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/MinHeap.js":"24","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Components/DijkstraModal.js":"25"},{"size":500,"mtime":1732574245068,"results":"26","hashOfConfig":"27"},{"size":127,"mtime":1732574245061,"results":"28","hashOfConfig":"27"},{"size":362,"mtime":1732574245068,"results":"29","hashOfConfig":"27"},{"size":2134,"mtime":1732574245064,"results":"30","hashOfConfig":"27"},{"size":14924,"mtime":1732574245064,"results":"31","hashOfConfig":"27"},{"size":6185,"mtime":1732602119062,"results":"32","hashOfConfig":"27"},{"size":149,"mtime":1732574245066,"results":"33","hashOfConfig":"27"},{"size":3431,"mtime":1732574245064,"results":"34","hashOfConfig":"27"},{"size":2385,"mtime":1732574245064,"results":"35","hashOfConfig":"27"},{"size":18221,"mtime":1732574245066,"results":"36","hashOfConfig":"27"},{"size":3172,"mtime":1732574245063,"results":"37","hashOfConfig":"27"},{"size":2531,"mtime":1732574245065,"results":"38","hashOfConfig":"27"},{"size":2163,"mtime":1732574245062,"results":"39","hashOfConfig":"27"},{"size":2030,"mtime":1732574245063,"results":"40","hashOfConfig":"27"},{"size":2918,"mtime":1732574245063,"results":"41","hashOfConfig":"27"},{"size":1571,"mtime":1732574245063,"results":"42","hashOfConfig":"27"},{"size":5950,"mtime":1732574245062,"results":"43","hashOfConfig":"27"},{"size":2300,"mtime":1732574245062,"results":"44","hashOfConfig":"27"},{"size":1334,"mtime":1732574245066,"results":"45","hashOfConfig":"27"},{"size":464,"mtime":1732574245067,"results":"46","hashOfConfig":"27"},{"size":155,"mtime":1732574245067,"results":"47","hashOfConfig":"27"},{"size":474,"mtime":1732574245067,"results":"48","hashOfConfig":"27"},{"size":679,"mtime":1732574245067,"results":"49","hashOfConfig":"27"},{"size":1987,"mtime":1732574245067,"results":"50","hashOfConfig":"27"},{"size":2592,"mtime":1732574245065,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},"2z8caq",{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"54"},{"filePath":"64","messages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":null},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"54"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"54"},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"54"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"54"},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"54"},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89","usedDeprecatedRules":"54"},{"filePath":"90","messages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92","usedDeprecatedRules":"54"},{"filePath":"93","messages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"54"},{"filePath":"96","messages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98","usedDeprecatedRules":"54"},{"filePath":"99","messages":"100","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"101","messages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103","usedDeprecatedRules":"54"},{"filePath":"104","messages":"105","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"106","messages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"108","messages":"109","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"54"},{"filePath":"110","messages":"111","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"112","usedDeprecatedRules":"54"},{"filePath":"113","messages":"114","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"115","usedDeprecatedRules":"54"},"/home/ahmad/Documents/Discrete/algo-visualizer/src/index.js",[],["116","117"],"/home/ahmad/Documents/Discrete/algo-visualizer/src/App.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/reportWebVitals.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/Layout/Layout.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Canvas.js",["118","119","120","121"],"import { v4 as uuidv4 } from \"uuid\";\nimport React from \"react\";\nimport Edge from \"./Edge\";\nimport Vertex from \"./Vertex\";\nimport DfsVisualization from \"../../algorithms/DFS/DfsVisualization\";\nimport BfsVisualization from \"../../algorithms/BFS/BfsVisualization\";\nimport KruskalVisualization from \"../../algorithms/Kruskal/KruskalVisualization\";\nimport PrimVisualization from \"../../algorithms/Prim/PrimVisualization\";\nimport DijkstraVisualization from \"../../algorithms/Dijkstra/DijkstraVisualization\";\nimport TopologicalSortVisualization from \"../../algorithms/TopologicalSort/TopologicalSortVisualization\";\nimport AdjList from \"../AdjList/AdjList\";\nimport TopoModal from \"../TopoModal/TopoModal\";\n\nclass Canvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.vertexIDs = [];\n    this.edgeRefs = new Map();\n    this.vertexRefs = new Map();\n    this.adjList = new Map();\n    this.directedTo = new Map();\n\n    // this stores the directed edge incident TO a vertex\n    this.state = {\n      visualize: false,\n      noOfVertices: 0,\n      vertices: [],\n      edges: [],\n      topoSort: [],\n    };\n  }\n\n  moveEdge = (vertexID, x, y) => {\n    for (var i = 0; i < this.adjList.get(vertexID).length; i++) {\n      const id = this.adjList.get(vertexID)[i];\n      this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\n    }\n    if (this.directedTo.has(vertexID)) {\n      for (var i = 0; i < this.directedTo.get(vertexID).length; i++) {\n        const id = this.directedTo.get(vertexID)[i];\n        this.edgeRefs.get(id).current.changePosition(vertexID, x, y);\n      }\n    }\n  };\n\n  addVertex = () => {\n    var newVertices = this.state.vertices.map((vertex) => vertex);\n    const newVertexRef = React.createRef();\n    const uniqueID = uuidv4();\n    newVertices.push(\n      <Vertex\n        ref={newVertexRef}\n        vertexIndex={this.state.noOfVertices}\n        moveIncidentEdges={this.moveEdge}\n        uniqueID={uniqueID}\n        key={uniqueID}\n      />\n    );\n    this.vertexIDs.push(uniqueID);\n    this.vertexRefs.set(uniqueID, newVertexRef);\n    this.adjList.set(uniqueID, []);\n\n    this.setState({\n      vertices: newVertices,\n      noOfVertices: this.state.noOfVertices + 1,\n    });\n  };\n\n  isEdgePresent = (n1ID, n2ID, isDirected) => {\n    for (var i = 0; i < this.adjList.get(n1ID).length; i++) {\n      const edgeRef = this.edgeRefs.get(this.adjList.get(n1ID)[i]);\n      if (edgeRef.current.props.isDirected && edgeRef.current.n2ID === n2ID) {\n        return this.adjList.get(n1ID)[i];\n      }\n      if (\n        !edgeRef.current.props.isDirected &&\n        (edgeRef.current.n1ID === n2ID || edgeRef.current.n2ID === n2ID)\n      ) {\n        return this.adjList.get(n1ID)[i];\n      }\n    }\n\n    // Directed edge from n2 to n1 exists and user trying to\n    // add Un-Directed edge from n1 to n2\n    if (!isDirected && this.directedTo.has(n1ID)) {\n      for (var i = 0; i < this.directedTo.get(n1ID).length; i++) {\n        const edgeRef = this.edgeRefs.get(this.directedTo.get(n1ID)[i]);\n        if (edgeRef.current.n1ID == n2ID) return this.directedTo.get(n1ID)[i];\n      }\n    }\n    return false;\n  };\n  // CASE 1 - Un-Directed edge from n1 to n2 exists\n  // Can NOT add any other edge between n1 and n2\n\n  // CASE 2 - Directed edge from n1 to n2 exists\n  // Can only add Directed edge from n2 to n1\n  // Can NOT add any Un- directed edge between n1 and n2\n\n  addEdge = (n1, n2, isDirected, weight) => {\n    const n1ID = this.vertexIDs[n1];\n    const n2ID = this.vertexIDs[n2];\n    if (this.isEdgePresent(n1ID, n2ID, isDirected) !== false) {\n      // console.log(\"edge already +nt\");\n      return;\n    }\n\n    const newEdgeRef = React.createRef();\n    const uniqueID = uuidv4();\n    var newEdges = this.state.edges.map((edge) => edge);\n\n    newEdges.push(\n      <Edge\n        weight={weight}\n        ref={newEdgeRef}\n        key={uniqueID}\n        n1Ref={this.vertexRefs.get(n1ID)}\n        n2Ref={this.vertexRefs.get(n2ID)}\n        edgeKey={uniqueID}\n        isDirected={isDirected}\n      />\n    );\n\n    this.edgeRefs.set(uniqueID, newEdgeRef);\n\n    this.adjList.get(n1ID).push(uniqueID);\n    if (!isDirected) this.adjList.get(n2ID).push(uniqueID);\n\n    if (isDirected) {\n      if (this.directedTo.has(n2ID)) this.directedTo.get(n2ID).push(uniqueID);\n      else this.directedTo.set(n2ID, [uniqueID]);\n    }\n\n    this.setState({\n      edges: newEdges,\n    });\n  };\n\n  clearCanvas = () => {\n    this.vertexIDs = [];\n    this.edgeRefs = new Map();\n    this.vertexRefs = new Map();\n    this.adjList = new Map();\n    this.directedTo = new Map();\n\n    this.setState({\n      visualize: false,\n      noOfVertices: 0,\n      vertices: [],\n      edges: [],\n      topoSort: [],\n    });\n    this.props.visualizationEnd();\n  };\n\n  // check for optimisation\n  deleteVertex = (vertexIndex) => {\n    const uniqueID = this.vertexIDs[vertexIndex];\n    this.vertexRefs.delete(uniqueID);\n\n    const incidentEdges = this.adjList.get(uniqueID);\n\n    for (var i = 0; i < incidentEdges.length; i++) {\n      const edgeID = incidentEdges[i];\n      const edgeRef = this.edgeRefs.get(edgeID);\n      this.edgeRefs.delete(edgeID);\n\n      const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\n\n      if (edgeRef.current.props.isDirected) {\n        const updatedNeighbour = this.directedTo\n          .get(connectedVertexID)\n          .filter((id) => id !== edgeID);\n\n        this.directedTo.set(connectedVertexID, updatedNeighbour);\n      } else {\n        const updatedNeighbour = this.adjList\n          .get(connectedVertexID)\n          .filter((id) => id !== edgeID);\n\n        this.adjList.set(connectedVertexID, updatedNeighbour);\n      }\n    }\n\n    if (this.directedTo.has(uniqueID)) {\n      const incomingDirectedEdges = this.directedTo.get(uniqueID);\n      for (var i = 0; i < incomingDirectedEdges.length; i++) {\n        const edgeID = incomingDirectedEdges[i];\n        const edgeRef = this.edgeRefs.get(edgeID);\n        this.edgeRefs.delete(edgeID);\n        const connectedVertexID = edgeRef.current.getOtherVertexID(uniqueID);\n\n        const updatedNeighbour = this.adjList\n          .get(connectedVertexID)\n          .filter((id) => id !== edgeID);\n\n        this.adjList.set(connectedVertexID, updatedNeighbour);\n      }\n      this.directedTo.delete(uniqueID);\n    }\n\n    this.vertexIDs.splice(vertexIndex, 1);\n    this.adjList.delete(uniqueID);\n\n    for (i = vertexIndex; i < this.state.noOfVertices - 1; i++) {\n      const ind = this.vertexRefs.get(this.vertexIDs[i]).current.state\n        .vertexIndex;\n      if (ind > vertexIndex) {\n        this.vertexRefs\n          .get(this.vertexIDs[i])\n          .current.changeVertexIndex(ind - 1);\n      }\n    }\n\n    this.setState({\n      noOfVertices: this.state.noOfVertices - 1,\n      vertices: this.state.vertices.filter(\n        (vertex) => vertex.props.uniqueID !== uniqueID\n      ),\n      edges: this.state.edges.filter(\n        (edge) =>\n          edge.props.n1Ref.current.id !== uniqueID &&\n          edge.props.n2Ref.current.id !== uniqueID\n      ),\n    });\n  };\n\n  deleteEdge = (n1, n2) => {\n    const n1ID = this.vertexIDs[n1];\n    const n2ID = this.vertexIDs[n2];\n\n    var toDeleteEdgeID = this.isEdgePresent(n1ID, n2ID, true);\n    if (toDeleteEdgeID === false) {\n      // console.log(\"edge NOT +nt\");\n      return;\n    }\n\n    const toDeleteEdgeRef = this.edgeRefs.get(toDeleteEdgeID);\n    this.edgeRefs.delete(toDeleteEdgeID);\n\n    const updated1Neighbour = this.adjList\n      .get(n1ID)\n      .filter((edgeID) => edgeID !== toDeleteEdgeID);\n    this.adjList.set(n1ID, updated1Neighbour);\n\n    if (toDeleteEdgeRef.current.props.isDirected === false) {\n      const updated2Neighbour = this.adjList\n        .get(n2ID)\n        .filter((edgeID) => edgeID !== toDeleteEdgeID);\n      this.adjList.set(n2ID, updated2Neighbour);\n    }\n\n    if (toDeleteEdgeRef.current.props.isDirected) {\n      const updated = this.directedTo\n        .get(n2ID)\n        .filter((edgeID) => edgeID !== toDeleteEdgeID);\n      this.directedTo.set(n2ID, updated);\n    }\n\n    this.setState({\n      edges: this.state.edges.filter(\n        (edge) => edge.props.edgeKey !== toDeleteEdgeID\n      ),\n    });\n  };\n\n  // add code for getting starting vertex as input\n  startVisualizing = () => {\n    this.props.visualizationStart();\n  };\n\n  endVisualizing = () => {\n    this.props.visualizationEnd();\n  };\n\n  reset = () => {\n    this.vertexRefs.forEach((ref) => ref.current.changeBackgroundColor(\"aqua\"));\n    this.edgeRefs.forEach((ref) => ref.current.changeBackgroundColor(\"black\"));\n    this.props.visualizationEnd();\n  };\n\n  checkIfAllEdgesAreDirected = () => {\n    const adj = [...this.adjList.entries()];\n\n    for (var i = 0; i < adj.length; i++) {\n      const entry = adj[i][1];\n      for (var j = 0; j < entry.length; j++) {\n        const edgeRef = this.edgeRefs.get(entry[j]);\n\n        if (!edgeRef.current.props.isDirected) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  isCyclic = () => {\n    const vertexIndices = new Map();\n    const V = this.state.noOfVertices;\n    for (var i = 0; i < V; i++) {\n      vertexIndices.set(this.vertexIDs[i], i);\n    }\n\n    let visited = new Array(V).fill(false);\n    let recStack = new Array(V).fill(false);\n\n    // Call the recursive helper function to\n    // detect cycle in different DFS trees\n    for (let i = 0; i < V; i++)\n      if (\n        this.isCyclicUtil(this.vertexIDs[i], vertexIndices, visited, recStack)\n      )\n        return true;\n\n    return false;\n  };\n\n  isCyclicUtil = (vertexID, vertexIndices, visited, recStack) => {\n    var index = vertexIndices.get(vertexID);\n\n    if (!visited[index]) {\n      visited[index] = true;\n      recStack[index] = true;\n\n      const incidentEdges = this.adjList.get(vertexID);\n      const connectedVerticesID = incidentEdges.map((id) =>\n        this.edgeRefs.get(id).current.getOtherVertexID(vertexID)\n      );\n\n      for (let c = 0; c < connectedVerticesID.length; c++) {\n        const otherIndex = vertexIndices.get(connectedVerticesID[c]);\n\n        if (\n          !visited[otherIndex] &&\n          this.isCyclicUtil(\n            connectedVerticesID[c],\n            vertexIndices,\n            visited,\n            recStack\n          )\n        )\n          return true;\n        else if (recStack[otherIndex]) return true;\n      }\n      recStack[index] = false;\n      return false;\n    }\n  };\n\n  isGraphDAG = () => {\n    if (!this.checkIfAllEdgesAreDirected()) {\n      console.log(\"There are undirected edges in your graph\");\n      return false;\n    }\n\n    if (this.isCyclic()) {\n      console.log(\"There is a cycle in your graph\");\n      return false;\n    }\n\n    return true;\n  };\n\n  setTopoSort = (array) => {\n    const revArray = [];\n\n    for (var i = array.length - 1; i >= 0; i--) {\n      revArray.push(array[i]);\n    }\n\n    // console.log(revArray);\n\n    this.setState({ topoSort: revArray });\n  };\n\n  render() {\n    return (\n      <>\n        <div className=\"graph\">\n          {this.state.vertices}\n          {this.state.edges}\n          {this.props.isVisualizing &&\n          this.props.selectedAlgorithm === \"DFS\" ? (\n            <DfsVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n            />\n          ) : null}\n          {this.props.isVisualizing &&\n          this.props.selectedAlgorithm === \"BFS\" ? (\n            <BfsVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n            />\n          ) : null}\n          {this.props.isVisualizing &&\n          this.props.selectedAlgorithm === \"Kruskal MST\" ? (\n            <KruskalVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n            />\n          ) : null}\n          {this.props.isVisualizing &&\n          this.props.selectedAlgorithm === \"Prim MST\" ? (\n            <PrimVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n            />\n          ) : null}\n          {this.props.selectedAlgorithm === \"Dijkstra\" ? (\n            <DijkstraVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n              isVisualizing={this.props.isVisualizing}\n              edges={this.state.edges}\n            />\n          ) : null}\n          {this.props.isVisualizing &&\n          this.props.selectedAlgorithm === \"Topological Sort\" ? (\n            <TopologicalSortVisualization\n              startingVertex={parseInt(this.props.startNode)}\n              noOfVertices={this.state.noOfVertices}\n              vertexIDs={this.vertexIDs}\n              vertexRefs={this.vertexRefs}\n              edgeRefs={this.edgeRefs}\n              adjList={this.adjList}\n              endVisualizing={this.endVisualizing}\n              visualizationSpeed={this.props.visualizationSpeed}\n              setTopoModalOpen={this.props.setTopoModalOpen}\n              setTopoSort={this.setTopoSort}\n            />\n          ) : null}\n        </div>\n        <AdjList\n          adjList={this.adjList}\n          nodeIndices={this.vertexIDs}\n          edgeRefs={this.edgeRefs}\n          open={this.props.open}\n        ></AdjList>\n        <TopoModal\n          topoSort={this.state.topoSort}\n          open={this.props.topoModalOpen}\n          setTopoModalOpen={this.props.setTopoModalOpen}\n        ></TopoModal>\n      </>\n    );\n  }\n}\n\nexport default Canvas;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Header/Header.js",["122","123","124","125"],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Menu/AlgorithmOptions.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Edge.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/GraphComponents/Vertex.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Header/Drawer.js",["126","127","128","129","130","131","132","133","134"],"import React, { useState, useEffect } from \"react\";\nimport { makeStyles, useTheme } from \"@material-ui/core/styles\";\nimport Drawer from \"@material-ui/core/Drawer\";\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft/\";\nimport TimelineIcon from \"@material-ui/icons/Timeline\";\nimport AddNodeIcon from \"@material-ui/icons/Add\";\nimport ListItemIcon from \"@material-ui/core/ListItemIcon\";\nimport UndirectedEdgeIcon from \"@material-ui/icons/RemoveOutlined\";\nimport DirectedEdgeIcon from \"@material-ui/icons/ArrowForwardOutlined\";\nimport DeleteIcon from \"@material-ui/icons/Delete\";\nimport BookIcon from \"@material-ui/icons/Book\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Divider from \"@material-ui/core/Divider\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Menu from \"../Menu/Menu\";\nimport AlgorithmOptions from \"../Menu/AlgorithmOptions\";\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\nimport ListItemText from \"@material-ui/core/ListItemText\";\nimport Button from \"@material-ui/core/Button\";\nimport FormGroup from \"@material-ui/core/FormGroup\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport TextField from \"@material-ui/core/TextField\";\nimport Switch from \"@material-ui/core/Switch\";\nimport SettingsIcon from \"@material-ui/icons/Settings\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Radio from \"@material-ui/core/Radio\";\nimport RadioGroup from \"@material-ui/core/RadioGroup\";\nimport FormLabel from \"@material-ui/core/FormLabel\";\nimport Slider from '@material-ui/core/Slider';\n\nconst drawerWidth = 400;\nconst useStyles = makeStyles((theme) => ({\n  hide: {\n    display: \"none\",\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0,\n  },\n  drawerPaper: {\n    width: drawerWidth,\n  },\n  slider: {\n    width: \"50%\"\n  },\n  drawerHeader: {\n    //overflowY: \"scroll\",\n    display: \"flex\",\n    alignItems: \"center\",\n    padding: theme.spacing(0, 1),\n    // necessary for content to be below app bar\n    ...theme.mixins.toolbar,\n    justifyContent: \"flex-end\",\n  },\n  drawerContent: {\n    overflowY: \"scroll\",\n    display: \"flex\",\n    //alignItems: \"center\",\n    padding: theme.spacing(0, 1),\n    // necessary for content to be below app bar\n    ...theme.mixins.toolbar,\n    justifyContent: \"flex-end\",\n  },\n  buttonContainer: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    padding: theme.spacing(0, 1, 1),\n  },\n  visualizeButton: {\n    alignItems: \"center\",\n    padding: theme.spacing(2, 1, 2),\n  },\n}));\nconst CustomDrawer = (props) => {\n  const classes = useStyles();\n  const theme = useTheme();\n  const [algorithmMenuAnchor, setAlgorithmMenuAnchor] = useState(null);\n  const algorithmMenuOpen = Boolean(algorithmMenuAnchor);\n\n  const [addEdgeFromMenuAnchor, setAddEdgeFromMenuAnchor] = useState(null);\n  const [addEdgeFrom, setAddEdgeFrom] = useState(\"From\");\n  const [addEdgeTo, setAddEdgeTo] = useState(\"To\");\n  const addEdgeFromMenuOpen = Boolean(addEdgeFromMenuAnchor);\n  const [addEdgeToMenuAnchor, setAddEdgeToMenuAnchor] = useState(null);\n  const addEdgeToMenuOpen = Boolean(addEdgeToMenuAnchor);\n\n  const [nodeIndices, setNodeIndices] = useState([]);\n  const [deleteNode, setDeleteNode] = useState(\"Index\");\n  const [deleteNodeMenuAnchor, setDeleteNodeMenuAnchor] = useState(null);\n  const deleteNodeMenuOpen = Boolean(deleteNodeMenuAnchor);\n\n  const [deleteEdgeFromMenuAnchor, setDeleteEdgeFromMenuAnchor] =\n    useState(null);\n  const [deleteEdgeFrom, setDeleteEdgeFrom] = useState(\"From\");\n  const [deleteEdgeTo, setDeleteEdgeTo] = useState(\"To\");\n  const deleteEdgeFromMenuOpen = Boolean(deleteEdgeFromMenuAnchor);\n  const [deleteEdgeToMenuAnchor, setDeleteEdgeToMenuAnchor] = useState(null);\n  const deleteEdgeToMenuOpen = Boolean(deleteEdgeToMenuAnchor);\n\n  const [isDirectedEdge, setIsDirectedEdge] = useState(false);\n  const [isWeightedGraph, setIsWeightedGraph] = useState(null);\n  const [edgeWeight, setEdgeWeight] = useState(null);\n\n  const [startNodeMenuAnchor, setStartNodeMenuAnchor] = useState(null);\n  const startNodeMenuOpen = Boolean(startNodeMenuAnchor);\n\n  //const nodeIndices = []\n  useEffect(() => {\n    const newNodeIndices = [];\n    for (let i = 0; i < props.canvasRef.current.state.noOfVertices; i++) {\n      newNodeIndices.push(i);\n    }\n    // console.log(\"useEff\");\n    setNodeIndices(newNodeIndices);\n  }, [\n    props.canvasRef.current\n      ? props.canvasRef.current.state.noOfVertices\n      : props.canvasRef.current,\n  ]);\n\n  // [...Array(props.canvasRef.current.state.noOfVertices).keys()]\n  // useEffect(() => {\n  //     nodeIndices = [...Array(props.canvasRef.current.state.noOfVertices).keys()]\n  // }, [props.canvasRef.current.state.noOfVertices])\n  //console.log(props.canvasRef, nodeIndices);\n  const closeMenu = () => {\n    setAlgorithmMenuAnchor(null);\n    setAddEdgeFromMenuAnchor(null);\n    setAddEdgeToMenuAnchor(null);\n    setDeleteNodeMenuAnchor(null);\n    setDeleteEdgeFromMenuAnchor(null);\n    setDeleteEdgeToMenuAnchor(null);\n    setStartNodeMenuAnchor(null);\n  };\n\n  const openAlgorithmMenu = (e) => {\n    setAlgorithmMenuAnchor(e.currentTarget);\n  };\n\n  const selectAlgorithm = (algorithm) => {\n    props.selectAlgorithm(algorithm);\n    closeMenu();\n  };\n\n  const openAddEdgeFromMenu = (e) => {\n    setAddEdgeFromMenuAnchor(e.currentTarget);\n  };\n\n  const openAddEdgeToMenu = (e) => {\n    setAddEdgeToMenuAnchor(e.currentTarget);\n  };\n\n  const selectAddEdgeFrom = (from) => {\n    setAddEdgeFrom(from);\n    closeMenu();\n  };\n\n  const selectAddEdgeTo = (to) => {\n    setAddEdgeTo(to);\n    closeMenu();\n  };\n\n  const addEdge = (from, to) => {\n    props.canvasRef.current.addEdge(from, to, isDirectedEdge, edgeWeight);\n    setAddEdgeFrom(\"From\");\n    setAddEdgeTo(\"To\");\n  };\n\n  const openStartNodeMenu = (e) => {\n    setStartNodeMenuAnchor(e.currentTarget);\n  };\n\n  const selectStartNode = (node) => {\n    props.selectStartNode(node);\n    closeMenu();\n  };\n\n  const openDeleteNodeMenu = (e) => {\n    setDeleteNodeMenuAnchor(e.currentTarget);\n  };\n\n  const selectDeleteNode = (node) => {\n    setDeleteNode(node);\n    closeMenu();\n  };\n\n  const openDeleteEdgeFromMenu = (e) => {\n    setDeleteEdgeFromMenuAnchor(e.currentTarget);\n  };\n\n  const openDeleteEdgeToMenu = (e) => {\n    setDeleteEdgeToMenuAnchor(e.currentTarget);\n  };\n\n  const selectDeleteEdgeFrom = (from) => {\n    setDeleteEdgeFrom(from);\n    closeMenu();\n  };\n\n  const selectDeleteEdgeTo = (to) => {\n    setDeleteEdgeTo(to);\n    closeMenu();\n  };\n\n  const deleteEdge = (from, to) => {\n    props.canvasRef.current.deleteEdge(from, to);\n    setDeleteEdgeFrom(\"From\");\n    setDeleteEdgeTo(\"To\");\n  };\n\n  const checkDirectedEdge = () => {\n    setIsDirectedEdge((prev) => !prev);\n  };\n\n  const checkWeightedGraph = () => {\n    if (props.canvasRef.current.state.edges.length !== 0) {\n      const check = window.confirm(\"Changing Graph type will clear the canvas\");\n      if (check) {\n        props.canvasRef.current.clearCanvas();\n        if (isWeightedGraph === true) setEdgeWeight(null);\n        setIsWeightedGraph((prev) => !prev);\n      }\n    } else {\n      if (isWeightedGraph === true) setEdgeWeight(null);\n      setIsWeightedGraph((prev) => !prev);\n    }\n  };\n\n  const weightChangeHandler = (e) => {\n    setEdgeWeight(e.target.value);\n  };\n\n  const clearCanvas = () => {\n    props.canvasRef.current.clearCanvas();\n    setAddEdgeFrom(\"From\");\n    setAddEdgeTo(\"To\");\n    setDeleteEdgeFrom(\"From\");\n    setDeleteEdgeTo(\"To\");\n    setEdgeWeight(null);\n    props.selectStartNode(\"Start Node\");\n  };\n\n  return (\n    <Drawer\n      className={classes.drawer}\n      variant=\"persistent\"\n      anchor=\"left\"\n      open={props.open}\n      classes={{\n        paper: classes.drawerPaper,\n      }}\n    >\n      <div className={classes.drawerHeader}>\n        <Typography variant=\"h5\" align=\"center\" color=\"primary\">\n          CONTROL PANEL\n        </Typography>\n        <IconButton onClick={props.handleDrawerClose}>\n          {/* {theme.direction === \"ltr\" ? ( */}\n          <ChevronLeftIcon />\n          {/* ) : ( */}\n          {/* <ChevronRightIcon /> */}\n          {/* )} */}\n        </IconButton>\n      </div>\n      <Divider />\n      <div className={classes.drawerContent}>\n        <List>\n          <ListItem>\n            <ListItemIcon>\n              <TimelineIcon fontSize=\"large\" />\n            </ListItemIcon>\n            <ListItemText primary=\"Select Algorithm\" />\n            <Menu\n              selectOption={selectAlgorithm}\n              selectedOption={props.selectedAlgorithm}\n              open={algorithmMenuOpen}\n              anchor={algorithmMenuAnchor}\n              close={closeMenu}\n              options={props.AlgorithmOptions}\n              click={(e) => openAlgorithmMenu(e)}\n            ></Menu>\n          </ListItem>\n          <ListItem>\n            <ListItemIcon>\n              {/* <TimelineIcon fontSize=\"large\" /> */}\n            </ListItemIcon>\n            <ListItemText primary=\"Select Start Node\" />\n            <Menu\n              selectOption={selectStartNode}\n              selectedOption={props.startNode}\n              open={startNodeMenuOpen}\n              anchor={startNodeMenuAnchor}\n              close={closeMenu}\n              options={nodeIndices}\n              click={(e) => openStartNodeMenu(e)}\n            ></Menu>\n          </ListItem>\n          {/* <Divider /> */}\n\n\n          <ListItem>\n            <ListItemIcon>\n              {/* <TimelineIcon fontSize=\"large\" /> */}\n            </ListItemIcon>\n            <ListItemText primary=\"Speed\" />\n            <div className={classes.slider}>\n              <Slider\n                defaultValue={3}\n                // getAriaValueText={valuetext}\n                onChange={props.speedChange}\n                aria-labelledby=\"discrete-slider\"\n                valueLabelDisplay=\"auto\"\n                step={1}\n                marks\n                min={1}\n                max={10}\n              />\n            </div>\n          </ListItem>\n\n          <Divider />\n\n\n          {/* <ListItem>\n            <ListItemIcon>\n              <BookIcon />\n            </ListItemIcon>\n            <ListItemText\n              primary=\"Some Description About Algorithm\"\n              secondary=\"asfasfmc.ngkresjg jrgbkjrvgkjcrngjkergbkjergbjkdf vdn vjdsbgjkergbjdsv dsjgbkjsb vjnd djfg jh vdjnjdhg jdfv jdhrgvb d jdrhg jvh\"\n            ></ListItemText>\n          </ListItem>\n          <Divider /> */}\n          <ListItem>\n            <ListItemIcon>\n              <SettingsIcon fontSize=\"large\" />\n            </ListItemIcon>\n            {/* <FormControl>\n              <ListItemText primary=\"Graph Type\"></ListItemText>\n              <RadioGroup row>\n                <FormControlLabel\n                  value=\"false\"\n                  control={<Radio color=\"primary\" />}\n                  label=\"Un-Weighted\"\n                />\n                <FormControlLabel\n                  value=\"true\"\n                  control={<Radio color=\"primary\" />}\n                  label=\"Weighted\"\n                />\n              </RadioGroup>\n            </FormControl> */}\n            <FormGroup row>\n              <FormControlLabel\n                control={\n                  <Switch\n                    checked={isWeightedGraph}\n                    onChange={checkWeightedGraph}\n                    color=\"primary\"\n                  />\n                }\n                label=\"Weighted Graph\"\n                labelPlacement=\"start\"\n              />\n            </FormGroup>\n          </ListItem>\n          <Divider />\n          <ListItem>\n            <ListItemIcon>\n              <AddNodeIcon fontSize=\"large\" />\n            </ListItemIcon>\n            <ListItemText primary=\"Add a New Node\"></ListItemText>\n            <IconButton\n              color=\"primary\"\n              onClick={() => props.canvasRef.current.addVertex()}\n            >\n              <AddNodeIcon />\n            </IconButton>\n          </ListItem>\n          <Divider />\n          <ListItem>\n            <ListItemIcon>\n              {isDirectedEdge ? (\n                <DirectedEdgeIcon fontSize=\"large\" />\n              ) : (\n                <UndirectedEdgeIcon fontSize=\"large\" />\n              )}\n            </ListItemIcon>\n            <ListItemText primary=\"Add Edge\"></ListItemText>\n            <Menu\n              selectedOption={addEdgeFrom}\n              options={nodeIndices}\n              selectOption={selectAddEdgeFrom}\n              open={addEdgeFromMenuOpen}\n              anchor={addEdgeFromMenuAnchor}\n              close={closeMenu}\n              click={(e) => openAddEdgeFromMenu(e)}\n            ></Menu>\n            &nbsp;&nbsp;\n            <Menu\n              selectedOption={addEdgeTo}\n              options={nodeIndices}\n              selectOption={selectAddEdgeTo}\n              open={addEdgeToMenuOpen}\n              anchor={addEdgeToMenuAnchor}\n              close={closeMenu}\n              click={(e) => openAddEdgeToMenu(e)}\n            ></Menu>\n            <IconButton\n              color=\"primary\"\n              onClick={() =>\n                addEdge(parseInt(addEdgeFrom), parseInt(addEdgeTo))\n              }\n              disabled={\n                addEdgeFrom === addEdgeTo ||\n                addEdgeFrom === \"From\" ||\n                addEdgeTo === \"To\" ||\n                (isWeightedGraph && edgeWeight === null)\n              }\n            >\n              <AddNodeIcon />\n            </IconButton>\n          </ListItem>\n          <ListItem>\n            <ListItemIcon>\n              {/* {isDirectedEdge ? (\n                <DirectedEdgeIcon fontSize=\"large\" />\n              ) : (\n                <UndirectedEdgeIcon fontSize=\"large\" />\n              )} */}\n            </ListItemIcon>\n            <ListItemText primary=\"Directed\"></ListItemText>\n            <Switch\n              checked={isDirectedEdge}\n              onChange={checkDirectedEdge}\n              color=\"primary\"\n            />\n            <ListItemText primary=\"\"></ListItemText>\n            {isWeightedGraph ? (\n              <TextField\n                type=\"number\"\n                onChange={(e) => weightChangeHandler(e)}\n                label=\"Edge Weight\"\n                error={edgeWeight === \"\"}\n                style={{ width: \"130px\" }}\n              >\n                {edgeWeight}\n              </TextField>\n            ) : null}\n          </ListItem>\n          <Divider />\n          <ListItem>\n            <ListItemIcon>\n              <DeleteIcon fontSize=\"large\" />\n            </ListItemIcon>\n            <ListItemText primary=\"Delete Node\"></ListItemText>\n            <Menu\n              selectedOption={deleteNode}\n              options={nodeIndices}\n              selectOption={selectDeleteNode}\n              open={deleteNodeMenuOpen}\n              anchor={deleteNodeMenuAnchor}\n              close={closeMenu}\n              click={(e) => openDeleteNodeMenu(e)}\n            ></Menu>\n            <IconButton\n              color=\"primary\"\n              onClick={() => {\n                props.canvasRef.current.deleteVertex(parseInt(deleteNode));\n                setDeleteNode(\"Index\");\n              }}\n              disabled={deleteNode === \"Index\"}\n            >\n              <DeleteIcon />\n            </IconButton>\n          </ListItem>\n          <ListItem>\n            <ListItemIcon>{/* <DeleteIcon fontSize=\"large\" /> */}</ListItemIcon>\n            <ListItemText primary=\"Delete Edge\"></ListItemText> &nbsp;\n            <Menu\n              selectedOption={deleteEdgeFrom}\n              options={nodeIndices}\n              selectOption={selectDeleteEdgeFrom}\n              open={deleteEdgeFromMenuOpen}\n              anchor={deleteEdgeFromMenuAnchor}\n              close={closeMenu}\n              click={(e) => openDeleteEdgeFromMenu(e)}\n            ></Menu>\n            &nbsp;&nbsp;\n            <Menu\n              selectedOption={deleteEdgeTo}\n              options={nodeIndices}\n              selectOption={selectDeleteEdgeTo}\n              open={deleteEdgeToMenuOpen}\n              anchor={deleteEdgeToMenuAnchor}\n              close={closeMenu}\n              click={(e) => openDeleteEdgeToMenu(e)}\n            ></Menu>\n            <IconButton\n              color=\"primary\"\n              onClick={() =>\n                deleteEdge(parseInt(deleteEdgeFrom), parseInt(deleteEdgeTo))\n              }\n              disabled={\n                deleteEdgeFrom === deleteEdgeTo ||\n                deleteEdgeFrom === \"From\" ||\n                deleteEdgeTo === \"To\"\n              }\n            >\n              <DeleteIcon />\n            </IconButton>\n          </ListItem>\n        </List>\n      </div>\n      <Divider />\n      {/* <div className={classes.visualizeButtonContainer}> */}\n      &nbsp; &nbsp;\n      <Grid\n        container\n        direction=\"row\"\n        justify=\"space-evenly\"\n        alignItems=\"center\"\n        className={classes.buttonContainer}\n      >\n        {/* <Button\n          variant=\"contained\"\n          color=\"secondary\"\n          size=\"large\"\n          onClick={() => props.canvasRef.current.startVisualizing()}\n        >\n          VISUALIZE\n        </Button>\n        &nbsp; */}\n        {/* <Grid\n          container\n          direction=\"row\"\n          justify=\"space-around\"\n        //alignItems=\"center\"\n        //className={classes.visualizeButtonContainer}\n        > */}\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          size=\"large\"\n          onClick={() => props.canvasRef.current.reset()}\n        >\n          RESET\n        </Button>\n        &nbsp;&nbsp;\n        <Button\n          variant=\"contained\"\n          color=\"primary\"\n          size=\"large\"\n          onClick={() => clearCanvas()}\n        >\n          CLEAR\n        </Button>\n      </Grid>\n      {/* </Grid> */}\n      {/* </div> */}\n      {/* <div className={classes.visualizeButton}> */}\n      {/* </div> */}\n      {/* <Grid container spacing=\"1\">\n                <Grid justify=\"center\">\n                    Select Algorithm - <Menu open={algorithmMenuOpen} options={AlgorithmOptions}></Menu>\n                </Grid>\n\n            </Grid> */}\n    </Drawer>\n  );\n};\n\nexport default CustomDrawer;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/AdjList/AdjList.js",["135"],"import { useState, useEffect } from \"react\";\nimport Button from '@material-ui/core/Button'\nimport ButtonGroup from '@material-ui/core/ButtonGroup'\nimport { makeStyles } from '@material-ui/core/styles';\nimport Paper from '@material-ui/core/Paper';\nimport Fade from '@material-ui/core/Fade';\n\nconst useStyles = makeStyles((theme) => ({\n    container: {\n        display: 'flex',\n        margin: \"10vh 0 0 50vw\",\n    },\n    disabledButton: {\n        backgroundColor: '#808080'\n    },\n    paper: {\n        margin: theme.spacing(1),\n        zIndex: \"1000\",\n        width: \"100vw\",\n        overflow: \"scroll\",\n        maxHeight: \"80vh\",\n        backgroundColor: \"#000000\"\n    },\n    list: {\n        display: 'flex',\n        justifyContent: \"center\",\n        margin: \"auto auto\",\n        '& > *': {\n            margin: theme.spacing(1),\n        },\n    },\n\n    nodes: {\n        display: 'flex',\n        flexDirection: \"column\",\n        '& > *': {\n            margin: theme.spacing(0.2),\n        },\n    }\n\n}));\n\n\n\nconst AdjList = props => {\n    const classes = useStyles();\n    const nodes = props.nodeIndices.map((key) => (\n        <ButtonGroup\n            orientation=\"vertical\"\n            color=\"secondary\"\n            aria-label=\"vertical outlined primary button group\"\n        >\n            <Button key={key + \"123\"}>{props.nodeIndices.indexOf(key)}</Button>\n        </ButtonGroup>\n    ))\n    const [edges, setEdges] = useState(null)\n    useEffect(() => {\n        const newEdges = props.nodeIndices.map(key => {\n            let children\n            if (props.adjList.get(key).length === 0) {\n                children = (null)\n            }\n            else {\n                children = props.adjList.get(key).map(id => {\n                    const otherID = props.edgeRefs.get(id).current.getOtherVertexID(key)//getOtherNodeID(id, key)\n                    // console.log(otherID)\n                    return (<Button key={id}>\n                        {props.nodeIndices.indexOf(otherID)}\n                    </Button>)\n                })\n            }\n\n            return (\n                <ButtonGroup\n                    key={key}\n                    orientation=\"horizontal\"\n                    color=\"primary\"\n                    aria-label=\"horizontal contained primary button group\"\n                >\n                    {children}\n                    <Button disabled classes={{ disabled: classes.disabledButton }}>\\</Button>\n                </ButtonGroup >)\n\n        })\n\n        setEdges(newEdges)\n    }, [props])\n\n\n    return (\n        <>\n            <div className={classes.container}>\n                <Fade in={props.open}>\n                    <Paper elevation={4} className={classes.paper}>\n                        <div className={classes.list}>\n                            <div className={classes.nodes}>\n\n                                {nodes}\n                            </div>\n                            <div className={classes.nodes}>\n                                {edges}\n                            </div>\n                        </div>\n                    </Paper>\n                </Fade>\n            </div>\n\n        </>\n    );\n}\n\nexport default AdjList;","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/TopoModal/TopoModal.js",["136"],"import { useState, useEffect } from \"react\";\nimport Button from \"@material-ui/core/Button\";\nimport ButtonGroup from \"@material-ui/core/ButtonGroup\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport CloseIcon from \"@material-ui/icons/Close\";\nimport Typography from \"@material-ui/core/Typography\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Fade from \"@material-ui/core/Fade\";\n\nconst useStyles = makeStyles((theme) => ({\n  container: {\n    display: \"flex\",\n    margin: \"10vh 0 0 50vw\",\n  },\n  disabledButton: {\n    backgroundColor: \"#808080\",\n  },\n  paper: {\n    margin: theme.spacing(1),\n    zIndex: \"1000\",\n    width: \"40vw\",\n    // overflow: \"scroll\",\n    maxHeight: \"80vh\",\n    backgroundColor: \"#FFFFFF\",\n  },\n  list: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    margin: \"auto auto\",\n    \"& > *\": {\n      margin: theme.spacing(1),\n    },\n  },\n\n  nodes: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"& > *\": {\n      margin: theme.spacing(0.2),\n    },\n  },\n\n  button: {\n    \"& > *\": {\n      margin: theme.spacing(0.6),\n    },\n  },\n  heading: { margin: theme.spacing(0.6) },\n}));\n\nconst AdjList = (props) => {\n  const classes = useStyles();\n  const [children, setChildren] = useState(null);\n  useEffect(() => {\n    const newChildren = props.topoSort.map((key) => {\n      return (\n        <Button key={key} className={classes.button}>\n          {key}\n        </Button>\n      );\n    });\n\n    setChildren(newChildren);\n  }, [props]);\n\n  return (\n    <>\n      <div className={classes.container}>\n        <Fade in={props.open}>\n          <Paper elevation={4} className={classes.paper}>\n            <Typography variant=\"h6\" align=\"center\" className={classes.heading}>\n              Topological Sort\n              <IconButton\n                onClick={() => props.setTopoModalOpen(false)}\n                style={{ marginLeft: \"5%\" }}\n              >\n                <CloseIcon />\n              </IconButton>\n            </Typography>\n\n            {/* </div> */}\n            <div className={classes.list}>\n              <div className={classes.nodes}>\n                <ButtonGroup\n                  orientation=\"horizontal\"\n                  color=\"secondary\"\n                  aria-label=\"horizontal contained primary button group\"\n                >\n                  {children}\n                </ButtonGroup>\n              </div>\n            </div>\n          </Paper>\n        </Fade>\n      </div>\n    </>\n  );\n};\n\nexport default AdjList;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/BFS/BfsVisualization.js",["137"],"import { useState, useEffect } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\nimport Queue from \"../../helpers/dataStructures/Queue\";\n\n//const delayTime = 1000;\nconst BfsVisualization = (props) => {\n  const vertexIndices = new Map();\n  const delayTime = props.visualizationSpeed\n  const [visited, setVisited] = useState(\n    new Array(props.noOfVertices).fill(-1)\n  );\n  const BFS = async (vertexID) => {\n    const queue = new Queue();\n    // const newVisited = visited\n    // newVisited[vertexID] = 1;\n    // await asyncTimeOut(delayTime);\n    queue.enqueue(vertexID);\n\n    //setVisited(newVisited)\n    while (!queue.empty()) {\n      const frontVertexID = queue.front();\n      queue.dequeue();\n      const incidentEdges = props.adjList.get(frontVertexID);\n      const connectedVerticesID = incidentEdges.map((id) =>\n        props.edgeRefs.get(id).current.getOtherVertexID(frontVertexID)\n      );\n      for (var i = 0; i < connectedVerticesID.length; i++) {\n        const vertexIndex = vertexIndices.get(connectedVerticesID[i]);\n        if (visited[vertexIndex] === -1) {\n          const newVisited = visited;\n          newVisited[vertexIndex] = 1;\n          queue.enqueue(connectedVerticesID[i]);\n          await asyncTimeOut(delayTime);\n          props.edgeRefs\n            .get(incidentEdges[i])\n            .current.changeBackgroundColor(\"#01B878\");\n          props.vertexRefs\n            .get(connectedVerticesID[i])\n            .current.changeBackgroundColor(\"#01B878\");\n          setVisited(newVisited);\n        }\n      }\n    }\n  };\n\n  const visualizeBFS = async () => {\n    const newVisited = visited;\n    newVisited[props.startingVertex] = -1;\n\n    await asyncTimeOut(delayTime);\n    props.vertexRefs\n      .get(props.vertexIDs[props.startingVertex])\n      .current.changeBackgroundColor(\"#01B878\");\n\n    setVisited(newVisited);\n\n    await BFS(props.vertexIDs[props.startingVertex]);\n    props.endVisualizing();\n  };\n\n  useEffect(() => {\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n    }\n    visualizeBFS();\n  }, []);\n  return <div></div>;\n};\n\nexport default BfsVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Prim/PrimVisualization.js",["138","139","140"],"import { useState, useEffect } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\nimport MinHeap from \"../../helpers/dataStructures/MinHeap\";\n\n\n// const delayTime = 1000\nconst PrimVisualization = (props) => {\n  const vertexIndices = new Map();\n  const parent = new Array(props.noOfVertices);\n  const delayTime = props.visualizationSpeed\n  const visualizePrim = async () => {\n    const minHeap = new MinHeap(props.noOfVertices);\n    minHeap.decreaseKey(props.startingVertex, 0);\n\n    while (!minHeap.isEmpty()) {\n      const vertexID = props.vertexIDs[minHeap.extractMin()];\n      const neighbours = props.adjList\n        .get(vertexID)\n        .map((edgeID) => props.edgeRefs.get(edgeID));\n\n      props.vertexRefs.get(vertexID).current.changeBackgroundColor(\"#01B878\");\n      await asyncTimeOut(delayTime);\n\n      for (var i = 0; i < neighbours.length; i++) {\n        const connectedVertexIndex = vertexIndices.get(\n          neighbours[i].current.getOtherVertexID(vertexID)\n        );\n        if (!minHeap.isPresent(connectedVertexIndex)) continue;\n\n        const weight = parseInt(neighbours[i].current.props.weight);\n\n        neighbours[i].current.changeBackgroundColor(\"#ED3C61\");\n        await asyncTimeOut(delayTime);\n\n        if (minHeap.decreaseKey(connectedVertexIndex, weight)) {\n          const prevConnectedEdge = parent[connectedVertexIndex];\n\n          if (prevConnectedEdge != -1)\n            prevConnectedEdge.current.changeBackgroundColor(\"#CDCDCD\");\n\n          neighbours[i].current.changeBackgroundColor(\"#01B878\");\n          parent[connectedVertexIndex] = neighbours[i];\n        } else {\n          neighbours[i].current.changeBackgroundColor(\"#CDCDCD\");\n        }\n\n        await asyncTimeOut(delayTime);\n      }\n    }\n\n    props.endVisualizing();\n  };\n\n  useEffect(() => {\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n    }\n    parent.fill(-1);\n\n    visualizePrim();\n  }, []);\n\n  return <div></div>;\n};\n\nexport default PrimVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/TopologicalSort/TopologicalSortVisualization.js",["141"],"import { useState, useEffect } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\nimport Stack from \"../../helpers/dataStructures/Stack\";\n\n//const delayTime = 1000;\nconst TopologicalSortVisualization = (props) => {\n  const vertexIndices = new Map();\n  const stack = new Stack();\n  const delayTime = props.visualizationSpeed;\n  const [visited, setVisited] = useState(\n    new Array(props.noOfVertices).fill(false)\n  );\n\n  const TopoUtil = async (vertexID) => {\n    const incidentEdges = props.adjList.get(vertexID);\n    const connectedVerticesID = incidentEdges.map((id) =>\n      props.edgeRefs.get(id).current.getOtherVertexID(vertexID)\n    );\n\n    for (var i = 0; i < connectedVerticesID.length; i++) {\n      const vertexIndex = vertexIndices.get(connectedVerticesID[i]);\n\n      if (!visited[vertexIndex]) {\n        var newVisited = visited;\n        newVisited[vertexIndex] = true;\n\n        await asyncTimeOut(delayTime);\n\n        props.edgeRefs\n          .get(incidentEdges[i])\n          .current.changeBackgroundColor(\"#ED3C61\");\n        props.vertexRefs\n          .get(connectedVerticesID[i])\n          .current.changeBackgroundColor(\"#ED3C61\");\n\n        setVisited(newVisited);\n\n        await TopoUtil(connectedVerticesID[i]);\n        await asyncTimeOut(delayTime);\n\n        props.vertexRefs\n          .get(connectedVerticesID[i])\n          .current.changeBackgroundColor(\"#01B878\");\n        props.edgeRefs\n          .get(incidentEdges[i])\n          .current.changeBackgroundColor(\"#01B878\");\n      }\n    }\n\n    stack.push(vertexIndices.get(vertexID));\n  };\n\n  const visualizeTopologicalSort = async () => {\n    var newVisited = visited;\n    newVisited[props.startingVertex] = true;\n\n    await asyncTimeOut(delayTime);\n    props.vertexRefs\n      .get(props.vertexIDs[props.startingVertex])\n      .current.changeBackgroundColor(\"#ED3C61\");\n\n    setVisited(newVisited);\n\n    await TopoUtil(props.vertexIDs[props.startingVertex]);\n\n    for (var i = 0; i < props.noOfVertices; i++) {\n      if (!visited[i]) {\n        newVisited = visited;\n        newVisited[i] = true;\n\n        await asyncTimeOut(delayTime);\n        props.vertexRefs\n          .get(props.vertexIDs[i])\n          .current.changeBackgroundColor(\"#ED3C61\");\n\n        setVisited(newVisited);\n\n        await TopoUtil(props.vertexIDs[i]);\n      }\n    }\n\n    // console.log(stack.elements());\n    props.setTopoSort(stack.elements());\n    props.setTopoModalOpen(true);\n    props.endVisualizing();\n    // props.vertexRefs\n    //   .get(props.vertexIDs[props.startingVertex])\n    //   .current.changeBackgroundColor(\"#01B878\");\n  };\n\n  useEffect(() => {\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n    }\n\n    visualizeTopologicalSort();\n  }, []);\n\n  // create component for DFS data\n  // here we need to return that\n  return <div></div>;\n};\n\nexport default TopologicalSortVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Kruskal/KruskalVisualization.js",["142","143","144"],"import { useState, useEffect } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\nimport UnionFind from \"../../helpers/dataStructures/UnionFind\";\n\n//const delayTime = 1000;\nconst KruskalVisualization = (props) => {\n  const vertexIndices = new Map();\n  const edgeWeights = [];\n  const delayTime = props.visualizationSpeed\n  const visualizeKruskal = async () => {\n    const unionFind = new UnionFind(props.edgeRefs.size);\n\n    for (var i = 0; i < props.noOfVertices; i++) {\n      unionFind.makeSet(i);\n    }\n\n    for (var i = 0; i < edgeWeights.length; i++) {\n      const vertex1 = vertexIndices.get(edgeWeights[i][1].current.n1ID);\n      const vertex2 = vertexIndices.get(edgeWeights[i][1].current.n2ID);\n\n      const makeUnion = unionFind.union(vertex1, vertex2);\n\n      edgeWeights[i][1].current.changeBackgroundColor(\"#ED3C61\");\n      await asyncTimeOut(delayTime);\n      if (makeUnion) edgeWeights[i][1].current.changeBackgroundColor(\"#01B878\");\n      else edgeWeights[i][1].current.changeBackgroundColor(\"#CDCDCD\");\n      await asyncTimeOut(delayTime);\n    }\n\n    props.endVisualizing();\n  };\n\n  useEffect(() => {\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n    }\n\n    props.edgeRefs.forEach((edgeRef, edgeID) => {\n      edgeWeights.push([parseInt(edgeRef.current.props.weight), edgeRef]);\n    });\n\n    edgeWeights.sort((x, y) => {\n      if (y[0] < x[0]) return 1;\n      else return -1;\n    });\n\n    visualizeKruskal();\n  }, []);\n\n  return <div></div>;\n};\n\nexport default KruskalVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/Dijkstra/DijkstraVisualization.js",["145","146","147","148"],"import React, { useEffect, useState } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\nimport MinHeap from \"../../helpers/dataStructures/MinHeap\";\nimport DijskstraModal from \"../../components/UI/Components/DijkstraModal\";\n//const delayTime = 1000;\nconst DijkstraVisualization = (props) => {\n  const delayTime = props.visualizationSpeed;\n\n  const [vertexIndices, setVertexIndices] = useState(new Map());\n  const [nodeIndices, setNodeIndices] = useState(new Array(props.noOfVertices));\n  const [parent, setParents] = useState(new Array(props.noOfVertices));\n\n  const [showModal, setShowModal] = useState(false);\n  const [showVertexMenuAnchor, setShowVertexMenuAnchor] = useState(null);\n  const showVertexOpen = Boolean(showVertexMenuAnchor);\n  const [selectedVertex, setSelectedVertex] = useState(\"Select Vertex\");\n\n  const [message, setShowMessage] = useState(null);\n\n  const visualizeDijkstra = async () => {\n    if (props.noOfVertices === 0) props.endVisualizing();\n    let parent = new Array(props.noOfVertices);\n    let indices = new Array(props.noOfVertices);\n\n    let vertexIndices = new Map();\n\n    parent.fill(-1);\n\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n      indices[i] = i;\n    }\n    setNodeIndices(indices);\n    setVertexIndices(vertexIndices);\n\n    const minHeap = new MinHeap(props.noOfVertices);\n    minHeap.decreaseKey(props.startingVertex, 0);\n\n    while (!minHeap.isEmpty()) {\n      const currWeight = minHeap.getMinValue();\n      const vertexID = props.vertexIDs[minHeap.extractMin()];\n      const neighbours = props.adjList\n        .get(vertexID)\n        .map((edgeID) => props.edgeRefs.get(edgeID));\n\n      props.vertexRefs.get(vertexID).current.changeBackgroundColor(\"#01B878\");\n      await asyncTimeOut(delayTime);\n\n      for (var i = 0; i < neighbours.length; i++) {\n        const connectedVertexIndex = vertexIndices.get(\n          neighbours[i].current.getOtherVertexID(vertexID)\n        );\n        if (!minHeap.isPresent(connectedVertexIndex)) continue;\n        const weight = parseInt(neighbours[i].current.props.weight || 0);\n\n        neighbours[i].current.changeBackgroundColor(\"#ED3C61\");\n        await asyncTimeOut(delayTime);\n\n        if (minHeap.decreaseKey(connectedVertexIndex, currWeight + weight)) {\n          const prevConnectedEdge = parent[connectedVertexIndex];\n\n          if (prevConnectedEdge != -1)\n            prevConnectedEdge.current.changeBackgroundColor(\"#CDCDCD\");\n\n          neighbours[i].current.changeBackgroundColor(\"#01B878\");\n          parent[connectedVertexIndex] = neighbours[i];\n        } else {\n          neighbours[i].current.changeBackgroundColor(\"#CDCDCD\");\n        }\n\n        await asyncTimeOut(delayTime);\n      }\n    }\n    setParents(parent);\n    setShowModal(true);\n    props.endVisualizing();\n  };\n\n  const getShortestPath = (index) => {\n    let shortestPath = [];\n    let weight = 0;\n\n    let vertexId = props.vertexIDs[index];\n    let vertexIndex = index;\n    // parent[i] contains the edge in the shortest path\n    if (parent.length <= vertexIndex || vertexIndex === props.startingVertex) {\n      return;\n    } else if (parent[vertexIndex] === -1) {\n      let message = \"Vertex is not connected to source\";\n      setShowMessage(message);\n    } else {\n      //Resetting the previous path to the original color\n      props.edgeRefs.forEach((ref) => {\n        if (ref.current.state.styles.stroke === \"red\")\n          ref.current.changeBackgroundColor(\"#01B878\");\n      });\n\n      shortestPath.push(vertexIndex);\n\n      while (parent[vertexIndex] !== -1) {\n        weight += parseInt(parent[vertexIndex].current.props.weight || 0);\n        const connectedVertexId =\n          parent[vertexIndex].current.getOtherVertexID(vertexId);\n        const connectedVertexIndex = vertexIndices.get(connectedVertexId);\n        vertexIndex = connectedVertexIndex;\n        vertexId = connectedVertexId;\n        shortestPath.push(vertexIndex);\n      }\n      shortestPath.reverse();\n\n      shortestPath.forEach((index) => {\n        if (parent[index] !== -1)\n          parent[index].current.changeBackgroundColor(\"red\");\n      });\n\n      let message = (\n        <div>\n          <p style={{ margin: \"2px\" }}>\n            Shortest path : <b>{shortestPath.join(\" -> \")}</b>\n          </p>\n          <p style={{ margin: \"2px\" }}>\n            Total weight : <b>{weight}</b>\n          </p>\n        </div>\n      );\n      setShowMessage(message);\n    }\n  };\n\n  useEffect(() => {\n    if (!props.isVisualizing) {\n      return;\n    }\n    if (showModal) closeModal();\n    visualizeDijkstra();\n  }, [props.isVisualizing]);\n\n  useEffect(() => {\n    // A change in either of vertices, start node, edges should close the modal\n    if (showModal) closeModal();\n  }, [props.noOfVertices, props.startingVertex, props.edges]);\n\n  // useEffect(() => {\n  //   visualizeDijkstra();\n  // }, [vertexIndices, parent]);\n\n  //Functions related to modal\n  const closeMenu = () => {\n    setShowVertexMenuAnchor(null);\n  };\n\n  const openVertexMenu = (e) => {\n    setShowVertexMenuAnchor(e.currentTarget);\n  };\n\n  const selectVertex = (vertexIndex) => {\n    setSelectedVertex(vertexIndex);\n    closeMenu();\n    getShortestPath(vertexIndex);\n  };\n\n  const closeModal = () => {\n    setShowModal(false);\n    setSelectedVertex(\"Select Vertex\");\n    setShowMessage(null);\n  };\n\n  return (\n    <div>\n      {showModal ? (\n        <DijskstraModal\n          showModal={showModal}\n          closeModal={closeModal}\n          selectVertex={selectVertex}\n          openVertexMenu={openVertexMenu}\n          closeMenu={closeMenu}\n          startingVertex={props.startingVertex}\n          selectedVertex={selectedVertex}\n          message={message}\n          nodeIndices={nodeIndices}\n          showVertexMenuAnchor={showVertexMenuAnchor}\n          showVertexOpen={showVertexOpen}\n        />\n      ) : null}\n    </div>\n  );\n};\n\nexport default DijkstraVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/algorithms/DFS/DfsVisualization.js",["149"],"import { useState, useEffect } from \"react\";\nimport asyncTimeOut from \"../../helpers/asyncTimeOut\";\n\n//const delayTime = 1000;\nconst DfsVisualization = (props) => {\n  const vertexIndices = new Map();\n  const delayTime = props.visualizationSpeed\n  const [parent, setParent] = useState(new Array(props.noOfVertices).fill(-1));\n\n  const DFSAlgo = async (vertexID) => {\n    const incidentEdges = props.adjList.get(vertexID);\n    const connectedVerticesID = incidentEdges.map((id) =>\n      props.edgeRefs.get(id).current.getOtherVertexID(vertexID)\n    );\n\n    for (var i = 0; i < connectedVerticesID.length; i++) {\n      const vertexIndex = vertexIndices.get(connectedVerticesID[i]);\n\n      if (parent[vertexIndex] === -1) {\n        var newParent = parent;\n        newParent[vertexIndex] = vertexIndices.get(vertexID);\n\n        await asyncTimeOut(delayTime);\n\n        props.edgeRefs\n          .get(incidentEdges[i])\n          .current.changeBackgroundColor(\"#ED3C61\");\n        props.vertexRefs\n          .get(connectedVerticesID[i])\n          .current.changeBackgroundColor(\"#ED3C61\");\n\n        setParent(newParent);\n\n        await DFSAlgo(connectedVerticesID[i]);\n        await asyncTimeOut(delayTime);\n\n        props.vertexRefs\n          .get(connectedVerticesID[i])\n          .current.changeBackgroundColor(\"#01B878\");\n        props.edgeRefs\n          .get(incidentEdges[i])\n          .current.changeBackgroundColor(\"#01B878\");\n      }\n    }\n  };\n\n  const visualizeDFS = async () => {\n    var newParent = parent;\n    newParent[props.startingVertex] = props.startingVertex;\n\n    await asyncTimeOut(delayTime);\n    props.vertexRefs\n      .get(props.vertexIDs[props.startingVertex])\n      .current.changeBackgroundColor(\"#ED3C61\");\n\n    setParent(newParent);\n\n    await DFSAlgo(props.vertexIDs[props.startingVertex]);\n    \n    await asyncTimeOut(delayTime);\n\n    props.vertexRefs\n      .get(props.vertexIDs[props.startingVertex])\n      .current.changeBackgroundColor(\"#01B878\");\n      \n      props.endVisualizing();\n  };\n\n  useEffect(() => {\n    for (var i = 0; i < props.noOfVertices; i++) {\n      vertexIndices.set(props.vertexIDs[i], i);\n    }\n    visualizeDFS();\n  }, []);\n\n  // create component for DFS data\n  // here we need to return that\n  return <div></div>;\n};\n\nexport default DfsVisualization;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Menu/Menu.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/Queue.js",["150"],"class Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    empty = () => {\n        return this.items.length == 0;\n\n    }\n\n    enqueue = (el) => {\n        this.items.push(el)\n    }\n\n    dequeue = () => {\n        if (this.empty()) {\n            return null;\n        }\n\n        return this.items.shift();\n    }\n\n    front = () => {\n        if (this.empty()) {\n            return null;\n        }\n\n        return this.items[0];\n    }\n}\n\nexport default Queue;","/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/asyncTimeOut.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/Stack.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/UnionFind.js",[],"/home/ahmad/Documents/Discrete/algo-visualizer/src/helpers/dataStructures/MinHeap.js",["151","152","153"],"const MAX = 1000000;\nclass MinHeap {\n  constructor(len) {\n    this.size = len;\n    this.heap = [];\n    this.indexOf = [];\n\n    for (var i = 0; i < len; i++) {\n      this.heap.push([MAX, i]);\n      this.indexOf.push(i);\n    }\n  }\n\n  swap = (ind1, ind2) => {\n    this.indexOf[this.heap[ind1][1]] = ind2;\n    this.indexOf[this.heap[ind2][1]] = ind1;\n\n    const tmp = this.heap[ind1];\n    this.heap[ind1] = this.heap[ind2];\n    this.heap[ind2] = tmp;\n  };\n\n  parent = (ind) => {\n    return Math.floor((ind - 1) / 2);\n  };\n\n  decreaseKey = (vertex, val) => {\n    let index = this.indexOf[vertex];\n    if (this.heap[index][0] <= val) return false;\n\n    this.heap[index][0] = val;\n\n    while (\n      index !== 0 &&\n      this.heap[index][0] < this.heap[this.parent(index)][0]\n    ) {\n      this.swap(index, this.parent(index));\n      index = this.parent(index);\n    }\n\n    return true;\n  };\n\n  extractMin = () => {\n    if (this.size <= 0) return null;\n    if (this.size == 1) {\n      this.size = 0;\n      this.indexOf[this.heap[0][1]] = -1;\n      return this.heap[0][1];\n    }\n\n    const minElement = this.heap[0][1];\n    this.indexOf[minElement] = -1;\n\n    this.heap[0] = this.heap[this.size - 1];\n    this.indexOf[this.heap[0][1]] = 0;\n\n    this.size--;\n    this.minHeapify(0);\n\n    return minElement;\n  };\n\n  minHeapify = (par) => {\n    const left = 2 * par + 1;\n    const right = 2 * par + 2;\n    let smallest = par;\n\n    if (left < this.size && this.heap[left][0] < this.heap[smallest][0])\n      smallest = left;\n    if (right < this.size && this.heap[right][0] < this.heap[smallest][0])\n      smallest = right;\n\n    if (smallest != par) {\n      this.swap(par, smallest);\n      this.minHeapify(smallest);\n    }\n  };\n\n  isEmpty = () => {\n    if (this.size == 0) return true;\n    else return false;\n  };\n\n  isPresent = (vertex) => {\n    if (this.indexOf[vertex] === -1) return false;\n    return true;\n  };\n\n  getMinValue = () => {\n    return this.heap[0][0];\n  };\n}\n\nexport default MinHeap;\n","/home/ahmad/Documents/Discrete/algo-visualizer/src/components/UI/Components/DijkstraModal.js",["154","155"],"import Button from \"@material-ui/core/Button\";\nimport ButtonGroup from \"@material-ui/core/ButtonGroup\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport CloseIcon from \"@material-ui/icons/Close\";\nimport Typography from \"@material-ui/core/Typography\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Fade from \"@material-ui/core/Fade\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Menu from \"./../Menu/Menu\";\n\nconst useStyles = makeStyles((theme) => ({\n  container: {\n    display: \"flex\",\n    margin: \"10vh 0 30vw 0\",\n  },\n  disabledButton: {\n    backgroundColor: \"#808080\",\n  },\n  paper: {\n    position: \"absolute\",\n    top: \"70px\",\n    right: \"10px\",\n    zIndex: \"1000\",\n    minWidth: \"30vw\",\n    paddingBottom: \"10px\",\n    // overflow: \"scroll\",\n    maxHeight: \"80vh\",\n    backgroundColor: \"#FFFFFF\",\n    textAlign: \"center\",\n  },\n  list: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    margin: \"auto auto\",\n    \"& > *\": {\n      margin: theme.spacing(1),\n    },\n  },\n\n  nodes: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"& > *\": {\n      margin: theme.spacing(0.2),\n    },\n  },\n\n  grid: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"space-evenly\",\n  },\n\n  button: {\n    \"& > *\": {\n      margin: theme.spacing(0.6),\n    },\n  },\n  heading: { margin: theme.spacing(0.6) },\n  icon: {\n    position: \"absolute\",\n    right: \"10px\",\n  },\n}));\n\nconst DijskstraModal = (props) => {\n  const classes = useStyles();\n\n  return (\n    <Fade in={props.showModal}>\n      <Paper elevation={4} className={classes.paper}>\n        <Grid className={classes.grid}>\n          <Typography variant=\"h6\" align=\"center\" className={classes.heading}>\n            Get shortest path\n          </Typography>\n          <IconButton onClick={props.closeModal} className={classes.icon}>\n            <CloseIcon />\n          </IconButton>\n        </Grid>\n        <Grid className={classes.grid}>\n          <Typography> Source : {props.startingVertex}</Typography>\n\n          <Menu\n            selectOption={props.selectVertex}\n            selectedOption={props.selectedVertex}\n            open={props.showVertexOpen}\n            anchor={props.showVertexMenuAnchor}\n            close={props.closeMenu}\n            options={props.nodeIndices.filter(\n              (index) => index !== props.startingVertex\n            )}\n            click={(e) => props.openVertexMenu(e)}\n          ></Menu>\n        </Grid>\n        <Grid>{props.message}</Grid>\n      </Paper>\n    </Fade>\n  );\n};\n\nexport default DijskstraModal;\n",{"ruleId":"156","replacedBy":"157"},{"ruleId":"158","replacedBy":"159"},{"ruleId":"160","severity":1,"message":"161","line":39,"column":16,"nodeType":"162","messageId":"163","endLine":39,"endColumn":17},{"ruleId":"160","severity":1,"message":"161","line":86,"column":16,"nodeType":"162","messageId":"163","endLine":86,"endColumn":17},{"ruleId":"164","severity":1,"message":"165","line":88,"column":34,"nodeType":"166","messageId":"167","endLine":88,"endColumn":36},{"ruleId":"160","severity":1,"message":"161","line":187,"column":16,"nodeType":"162","messageId":"163","endLine":187,"endColumn":17},{"ruleId":"168","severity":1,"message":"169","line":82,"column":9,"nodeType":"162","messageId":"170","endLine":82,"endColumn":14},{"ruleId":"171","severity":1,"message":"172","line":113,"column":6,"nodeType":"173","endLine":117,"endColumn":4,"suggestions":"174"},{"ruleId":"171","severity":1,"message":"175","line":114,"column":5,"nodeType":"176","endLine":116,"endColumn":32},{"ruleId":"177","severity":1,"message":"178","line":172,"column":11,"nodeType":"179","messageId":"180","endLine":175,"endColumn":12,"fix":"181"},{"ruleId":"168","severity":1,"message":"182","line":11,"column":8,"nodeType":"162","messageId":"170","endLine":11,"endColumn":16},{"ruleId":"168","severity":1,"message":"183","line":17,"column":8,"nodeType":"162","messageId":"170","endLine":17,"endColumn":24},{"ruleId":"168","severity":1,"message":"184","line":27,"column":8,"nodeType":"162","messageId":"170","endLine":27,"endColumn":19},{"ruleId":"168","severity":1,"message":"185","line":28,"column":8,"nodeType":"162","messageId":"170","endLine":28,"endColumn":13},{"ruleId":"168","severity":1,"message":"186","line":29,"column":8,"nodeType":"162","messageId":"170","endLine":29,"endColumn":18},{"ruleId":"168","severity":1,"message":"187","line":30,"column":8,"nodeType":"162","messageId":"170","endLine":30,"endColumn":17},{"ruleId":"168","severity":1,"message":"169","line":80,"column":9,"nodeType":"162","messageId":"170","endLine":80,"endColumn":14},{"ruleId":"171","severity":1,"message":"172","line":119,"column":6,"nodeType":"173","endLine":123,"endColumn":4,"suggestions":"188"},{"ruleId":"171","severity":1,"message":"175","line":120,"column":5,"nodeType":"176","endLine":122,"endColumn":32},{"ruleId":"171","severity":1,"message":"189","line":87,"column":8,"nodeType":"173","endLine":87,"endColumn":15,"suggestions":"190"},{"ruleId":"171","severity":1,"message":"191","line":65,"column":6,"nodeType":"173","endLine":65,"endColumn":13,"suggestions":"192"},{"ruleId":"171","severity":1,"message":"193","line":66,"column":6,"nodeType":"173","endLine":66,"endColumn":8,"suggestions":"194"},{"ruleId":"168","severity":1,"message":"195","line":1,"column":10,"nodeType":"162","messageId":"170","endLine":1,"endColumn":18},{"ruleId":"164","severity":1,"message":"196","line":38,"column":33,"nodeType":"166","messageId":"167","endLine":38,"endColumn":35},{"ruleId":"171","severity":1,"message":"197","line":61,"column":6,"nodeType":"173","endLine":61,"endColumn":8,"suggestions":"198"},{"ruleId":"171","severity":1,"message":"199","line":97,"column":6,"nodeType":"173","endLine":97,"endColumn":8,"suggestions":"200"},{"ruleId":"168","severity":1,"message":"195","line":1,"column":10,"nodeType":"162","messageId":"170","endLine":1,"endColumn":18},{"ruleId":"160","severity":1,"message":"161","line":17,"column":14,"nodeType":"162","messageId":"163","endLine":17,"endColumn":15},{"ruleId":"171","severity":1,"message":"201","line":48,"column":6,"nodeType":"173","endLine":48,"endColumn":8,"suggestions":"202"},{"ruleId":"160","severity":1,"message":"161","line":49,"column":16,"nodeType":"162","messageId":"163","endLine":49,"endColumn":17},{"ruleId":"164","severity":1,"message":"196","line":62,"column":33,"nodeType":"166","messageId":"167","endLine":62,"endColumn":35},{"ruleId":"171","severity":1,"message":"203","line":136,"column":6,"nodeType":"173","endLine":136,"endColumn":27,"suggestions":"204"},{"ruleId":"171","severity":1,"message":"205","line":141,"column":6,"nodeType":"173","endLine":141,"endColumn":61,"suggestions":"206"},{"ruleId":"171","severity":1,"message":"207","line":74,"column":6,"nodeType":"173","endLine":74,"endColumn":8,"suggestions":"208"},{"ruleId":"164","severity":1,"message":"165","line":7,"column":34,"nodeType":"166","messageId":"167","endLine":7,"endColumn":36},{"ruleId":"164","severity":1,"message":"165","line":46,"column":19,"nodeType":"166","messageId":"167","endLine":46,"endColumn":21},{"ruleId":"164","severity":1,"message":"196","line":74,"column":18,"nodeType":"166","messageId":"167","endLine":74,"endColumn":20},{"ruleId":"164","severity":1,"message":"165","line":81,"column":19,"nodeType":"166","messageId":"167","endLine":81,"endColumn":21},{"ruleId":"168","severity":1,"message":"209","line":1,"column":8,"nodeType":"162","messageId":"170","endLine":1,"endColumn":14},{"ruleId":"168","severity":1,"message":"210","line":2,"column":8,"nodeType":"162","messageId":"170","endLine":2,"endColumn":19},"no-native-reassign",["211"],"no-negated-in-lhs",["212"],"no-redeclare","'i' is already defined.","Identifier","redeclared","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'theme' is assigned a value but never used.","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'props.canvasRef'. Either include it or remove the dependency array.","ArrayExpression",["213"],"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","ConditionalExpression","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","JSXOpeningElement","noTargetBlankWithoutNoreferrer",{"range":"214","text":"215"},"'BookIcon' is defined but never used.","'AlgorithmOptions' is defined but never used.","'FormControl' is defined but never used.","'Radio' is defined but never used.","'RadioGroup' is defined but never used.","'FormLabel' is defined but never used.",["216"],"React Hook useEffect has a missing dependency: 'classes.disabledButton'. Either include it or remove the dependency array.",["217"],"React Hook useEffect has a missing dependency: 'classes.button'. Either include it or remove the dependency array.",["218"],"React Hook useEffect has missing dependencies: 'props.noOfVertices', 'props.vertexIDs', 'vertexIndices', and 'visualizeBFS'. Either include them or remove the dependency array.",["219"],"'useState' is defined but never used.","Expected '!==' and instead saw '!='.","React Hook useEffect has missing dependencies: 'parent', 'props.noOfVertices', 'props.vertexIDs', 'vertexIndices', and 'visualizePrim'. Either include them or remove the dependency array.",["220"],"React Hook useEffect has missing dependencies: 'props.noOfVertices', 'props.vertexIDs', 'vertexIndices', and 'visualizeTopologicalSort'. Either include them or remove the dependency array.",["221"],"React Hook useEffect has missing dependencies: 'edgeWeights', 'props.edgeRefs', 'props.noOfVertices', 'props.vertexIDs', 'vertexIndices', and 'visualizeKruskal'. Either include them or remove the dependency array.",["222"],"React Hook useEffect has missing dependencies: 'showModal' and 'visualizeDijkstra'. Either include them or remove the dependency array.",["223"],"React Hook useEffect has a missing dependency: 'showModal'. Either include it or remove the dependency array.",["224"],"React Hook useEffect has missing dependencies: 'props.noOfVertices', 'props.vertexIDs', 'vertexIndices', and 'visualizeDFS'. Either include them or remove the dependency array.",["225"],"'Button' is defined but never used.","'ButtonGroup' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"226","fix":"227"},[5035,5035]," rel=\"noreferrer\"",{"desc":"226","fix":"228"},{"desc":"229","fix":"230"},{"desc":"231","fix":"232"},{"desc":"233","fix":"234"},{"desc":"235","fix":"236"},{"desc":"237","fix":"238"},{"desc":"239","fix":"240"},{"desc":"241","fix":"242"},{"desc":"243","fix":"244"},{"desc":"245","fix":"246"},"Update the dependencies array to be: [props.canvasRef]",{"range":"247","text":"248"},{"range":"249","text":"248"},"Update the dependencies array to be: [classes.disabledButton, props]",{"range":"250","text":"251"},"Update the dependencies array to be: [classes.button, props]",{"range":"252","text":"253"},"Update the dependencies array to be: [props.noOfVertices, props.vertexIDs, vertexIndices, visualizeBFS]",{"range":"254","text":"255"},"Update the dependencies array to be: [parent, props.noOfVertices, props.vertexIDs, vertexIndices, visualizePrim]",{"range":"256","text":"257"},"Update the dependencies array to be: [props.noOfVertices, props.vertexIDs, vertexIndices, visualizeTopologicalSort]",{"range":"258","text":"259"},"Update the dependencies array to be: [edgeWeights, props.edgeRefs, props.noOfVertices, props.vertexIDs, vertexIndices, visualizeKruskal]",{"range":"260","text":"261"},"Update the dependencies array to be: [props.isVisualizing, showModal, visualizeDijkstra]",{"range":"262","text":"263"},"Update the dependencies array to be: [props.noOfVertices, props.startingVertex, props.edges, showModal]",{"range":"264","text":"265"},"Update the dependencies array to be: [props.noOfVertices, props.vertexIDs, vertexIndices, visualizeDFS]",{"range":"266","text":"267"},[3083,3200],"[props.canvasRef]",[4486,4603],[2507,2514],"[classes.disabledButton, props]",[1521,1528],"[classes.button, props]",[2099,2101],"[props.noOfVertices, props.vertexIDs, vertexIndices, visualizeBFS]",[1964,1966],"[parent, props.noOfVertices, props.vertexIDs, vertexIndices, visualizePrim]",[2773,2775],"[props.noOfVertices, props.vertexIDs, vertexIndices, visualizeTopologicalSort]",[1502,1504],"[edgeWeights, props.edgeRefs, props.noOfVertices, props.vertexIDs, vertexIndices, visualizeKruskal]",[4616,4637],"[props.isVisualizing, showModal, visualizeDijkstra]",[4779,4834],"[props.noOfVertices, props.startingVertex, props.edges, showModal]",[2167,2169],"[props.noOfVertices, props.vertexIDs, vertexIndices, visualizeDFS]"]